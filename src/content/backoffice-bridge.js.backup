/**
 * S-Post - Bridge pour le Backoffice
 * Ce script est injecté sur votre app S-PostBO pour communiquer avec l'extension
 */

(function() {
  'use strict';
  
  // PROTECTION MAXIMALE : Rendre le bridge complètement optionnel
  // Si quoi que ce soit échoue, la page continue de fonctionner
  
  // Fonction wrapper pour exécuter du code de manière sûre
  function safeExecute(fn, fallback = null) {
    try {
      return fn();
    } catch (e) {
      // Ignorer silencieusement toutes les erreurs
      return fallback;
    }
  }
  
  // Vérifier que chrome.runtime est disponible de manière sûre
  const isExtensionAvailable = safeExecute(() => {
    return typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id;
  }, false);
  
  if (!isExtensionAvailable) {
    // Extension non disponible, sortir silencieusement
    // La page doit continuer à fonctionner normalement
    return;
  }
  
  // Initialiser de manière sûre
  safeExecute(() => {
    console.log('[S-Post Bridge] Initialisation sur', window.location.href);
  });

  // ============================================
  // Exposer les données LinkedIn à l'app
  // ============================================
  
  /**
   * L'app peut appeler cette fonction pour récupérer les données LinkedIn
   * Exemple: window.LinkedInPlanner.getData()
   */
  // Récupérer la version de manière sécurisée
  const extensionVersion = safeExecute(() => {
    if (chrome.runtime && chrome.runtime.getManifest) {
      return chrome.runtime.getManifest().version || 'unknown';
    }
    return 'unknown';
  }, 'unknown');
  
  // Créer l'API de manière sûre
  const bridgeAPI = {
    // Version de l'extension
    version: extensionVersion,
    
    // Récupérer les données LinkedIn
    getData: async function() {
      return new Promise((resolve, reject) => {
        // Vérifier que le contexte est encore valide
        try {
          if (!chrome.runtime || !chrome.runtime.id) {
            reject(new Error('Extension context invalidated. Please reload the page.'));
            return;
          }
          
          chrome.runtime.sendMessage({ type: 'get_linkedin_data' }, (response) => {
            if (chrome.runtime.lastError) {
              const errorMsg = chrome.runtime.lastError.message || 'Extension error';
              if (errorMsg.includes('context invalidated') || errorMsg.includes('Receiving end does not exist')) {
                reject(new Error('Extension context invalidated. Please reload the page.'));
              } else {
                reject(new Error(errorMsg));
              }
            } else {
              resolve(response);
            }
          });
        } catch (error) {
          reject(new Error('Extension context invalidated. Please reload the page.'));
        }
      });
    },
    
    // Vérifier si LinkedIn est connecté
    isConnected: async function() {
      const data = await this.getData();
      return data && data.connected === true;
    },
    
    // Récupérer le profil LinkedIn
    getProfile: async function() {
      const data = await this.getData();
      return data?.profile || null;
    },
    
    // Récupérer le CSRF token
    getCsrf: async function() {
      const data = await this.getData();
      return data?.csrf || null;
    },
    
    // Récupérer les listes locales
    getLists: async function() {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'get_list_refresh' }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response || []);
          }
        });
      });
    },
    
    // Créer une liste
    createList: async function(name) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'create_list', name }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Récupérer les brouillons
    getDrafts: async function() {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'get_drafts' }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response || []);
          }
        });
      });
    },
    
    // Sauvegarder un brouillon
    saveDraft: async function(draft) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'save_draft', draft }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Supprimer un brouillon
    deleteDraft: async function(id) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'delete_draft', id }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Récupérer les posts LinkedIn
    getPosts: async function() {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'get_posts' }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response || []);
          }
        });
      });
    },
    
    // Rafraîchir les posts depuis LinkedIn
    fetchPosts: async function() {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'fetch_linkedin_posts' }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Appel API Notion (contourne CORS)
    notionApiCall: async function(endpoint, method = 'GET', body = null, token = null, headers = {}) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({
          type: 'notion_api_call',
          endpoint: endpoint,
          method: method,
          body: body,
          token: token,
          headers: headers
        }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else if (response && response.error) {
            reject(new Error(response.error));
          } else if (response && !response.success) {
            reject(new Error(response.error || 'Erreur lors de l\'appel à l\'API Notion'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // ============================================
    // Posts programmés
    // ============================================
    
    // Récupérer les posts programmés
    getScheduledPosts: async function() {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'get_scheduled_posts' }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response || []);
          }
        });
      });
    },
    
    // Programmer un post
    schedulePost: async function(post) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'schedule_post', post }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Mettre à jour un post programmé
    updateScheduledPost: async function(post) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'update_scheduled_post', post }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Annuler un post programmé
    cancelScheduledPost: async function(id) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'cancel_scheduled_post', id }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Publier immédiatement
    publishNow: async function(post) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'publish_now', post }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
    
    // Dupliquer un brouillon
    cloneDraft: async function(id) {
      return new Promise((resolve, reject) => {
        if (!chrome.runtime || !chrome.runtime.id) {
          reject(new Error('Extension context invalidated'));
          return;
        }
        chrome.runtime.sendMessage({ type: 'clone_draft', id }, (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message || 'Extension error'));
          } else {
            resolve(response);
          }
        });
      });
    },
  };
  
  // Exposer l'API de manière sûre
  safeExecute(() => {
    window.SPost = window.LinkedInPlanner = bridgeAPI;
  });

  // ============================================
  // Émettre un événement quand l'extension est prête
  // ============================================
  
  // Fonction pour émettre les événements ready
  function emitReadyEvents() {
    try {
      console.log('[S-Post Bridge] Émission des événements ready');
      
      let version = 'unknown';
      try {
        if (chrome.runtime && chrome.runtime.getManifest) {
          version = chrome.runtime.getManifest().version || 'unknown';
        }
      } catch (e) {
        console.warn('[S-Post Bridge] Impossible de récupérer la version:', e);
      }
      
      // Événement S-Post
      window.dispatchEvent(new CustomEvent('SPostReady', {
        detail: { version: version }
      }));
      
      // Événement legacy pour compatibilité
      window.dispatchEvent(new CustomEvent('LinkedInPlannerReady', {
        detail: { version: version }
      }));
    } catch (e) {
      console.warn('[S-Post Bridge] Erreur lors de l\'émission des événements:', e);
    }
  }

  // Émettre immédiatement
  emitReadyEvents();
  
  // Réeemettre quand le DOM est prêt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', emitReadyEvents);
  }
  
  // Réeemettre quand tout est chargé
  window.addEventListener('load', emitReadyEvents);
  
  // Réeemettre après un délai (pour les apps React/SPA)
  setTimeout(emitReadyEvents, 500);
  setTimeout(emitReadyEvents, 1000);
  setTimeout(emitReadyEvents, 2000);

  // ============================================
  // Stocker les données dans localStorage pour l'app
  // ============================================
  
  async function syncToLocalStorage() {
    try {
      // Vérifier que le contexte de l'extension est encore valide
      if (!chrome.runtime || !chrome.runtime.id) {
        // Sortir silencieusement si le contexte est invalidé
        return;
      }
      
      console.log('[S-Post Bridge] Tentative de sync...');
      
      // Sync des données LinkedIn (profil, csrf, etc.)
      // Lire DIRECTEMENT depuis chrome.storage.local (plus fiable)
      let storage = {};
      try {
        storage = await chrome.storage.local.get(['pp_linkedin_session']);
      } catch (err) {
        // Si le contexte est invalidé, sortir silencieusement
        const errorMsg = err.message || err.toString() || '';
        if (errorMsg.includes('context') || errorMsg.includes('invalidated') || errorMsg.includes('Receiving end')) {
          return; // Sortir silencieusement, ne pas loguer
        }
        // Autre erreur, la logger mais ne pas bloquer
        console.warn('[S-Post Bridge] Erreur lecture storage (non bloquante)');
        return;
      }
      
      const linkedinSession = storage?.pp_linkedin_session;
      
      if (linkedinSession && linkedinSession.csrf) {
        const miniProfile = linkedinSession.profile;
        const data = {
          connected: linkedinSession.isConnected !== false, // Par défaut true si isConnected existe
          csrf: linkedinSession.csrf,
          profile: miniProfile ? {
            entityUrn: miniProfile.entityUrn,
            firstName: miniProfile.firstName,
            lastName: miniProfile.lastName,
            headline: miniProfile.occupation,
            publicIdentifier: miniProfile.publicIdentifier,
            picture: miniProfile.picture?.rootUrl 
              ? `${miniProfile.picture.rootUrl}${miniProfile.picture.artifacts?.[0]?.fileIdentifyingUrlPathSegment || ''}`
              : null,
            profileUrl: miniProfile.publicIdentifier 
              ? `https://www.linkedin.com/in/${miniProfile.publicIdentifier}`
              : null,
          } : null,
          me: linkedinSession.me || null,
          locale: linkedinSession.locale || 'fr',
          extractedAt: linkedinSession.extractedAt || new Date().toISOString(),
        };
        
        try {
          const extensionVersion = chrome.runtime?.getManifest?.()?.version || 'unknown';
          localStorage.setItem('spost_linkedin_data', JSON.stringify({
            ...data,
            updatedAt: new Date().toISOString(),
            extensionVersion: extensionVersion,
          }));
        } catch (e) {
          // Si chrome.runtime n'est pas disponible, sauvegarder quand même
          localStorage.setItem('spost_linkedin_data', JSON.stringify({
            ...data,
            updatedAt: new Date().toISOString(),
            extensionVersion: 'unknown',
          }));
        }
        
        // Dispatcher un événement pour que le BO réagisse immédiatement
        window.dispatchEvent(new CustomEvent('SPostDataUpdated', { detail: data }));
        window.dispatchEvent(new CustomEvent('LinkedInPlannerDataUpdated', { detail: data }));
        
        console.log('[S-Post Bridge] ✅ Données profil synchronisées');
      }
      
      // Sync des posts LinkedIn
      try {
        if (!chrome.runtime || !chrome.runtime.id) {
          return; // Sortir silencieusement
        }
        let postsStorage = {};
        try {
          postsStorage = await chrome.storage.local.get(['pp_posts']);
        } catch (err) {
          // Contexte invalidé, sortir silencieusement
          return;
        }
        const posts = postsStorage?.pp_posts || [];
        console.log('[S-Post Bridge] Posts récupérés:', posts?.length || 0);
        
        if (posts && posts.length > 0) {
          // Calculer les dates depuis les URNs si manquantes
          posts.forEach(post => {
            if (post.createdAt) return; // Déjà une date
            const urn = post.urn || post.id || '';
            const match = urn.match(/activity:(\d+)/);
            if (match) {
              try {
                const bigId = BigInt(match[1]);
                const timestamp = Number(bigId >> 22n);
                if (timestamp > 1400000000000 && timestamp < Date.now() + 86400000) {
                  post.createdAt = new Date(timestamp).toISOString();
                }
              } catch(e) {}
            }
          });
          
          localStorage.setItem('spost_posts', JSON.stringify(posts));
          const withDates = posts.filter(p => p.createdAt).length;
          console.log('[S-Post Bridge] ✅', posts.length, 'posts synchronisés (', withDates, 'avec dates)');
        }
      } catch (e) {
        console.log('[S-Post Bridge] Pas de posts disponibles');
      }
      
      // Sync des brouillons
      try {
        if (!chrome.runtime || !chrome.runtime.id) {
          return; // Sortir silencieusement
        }
        let draftsStorage = {};
        try {
          draftsStorage = await chrome.storage.local.get(['pp_drafts']);
        } catch (err) {
          // Contexte invalidé, sortir silencieusement
          return;
        }
        const drafts = draftsStorage?.pp_drafts || [];
        if (drafts && drafts.length > 0) {
          localStorage.setItem('spost_drafts', JSON.stringify(drafts));
          console.log('[S-Post Bridge] ✅', drafts.length, 'brouillons synchronisés');
        }
      } catch (e) {
        // Pas de brouillons
      }
      
      // Sync des posts programmés
      try {
        if (!chrome.runtime || !chrome.runtime.id) {
          return; // Sortir silencieusement
        }
        let scheduledStorage = {};
        try {
          scheduledStorage = await chrome.storage.local.get(['pp_scheduled_posts']);
        } catch (err) {
          // Contexte invalidé, sortir silencieusement
          return;
        }
        const scheduled = scheduledStorage?.pp_scheduled_posts || [];
        if (scheduled && scheduled.length > 0) {
          localStorage.setItem('spost_scheduled', JSON.stringify(scheduled));
          console.log('[S-Post Bridge] ✅', scheduled.length, 'posts programmés synchronisés');
        }
      } catch (e) {
        // Pas de posts programmés
      }
      
      // Sync des analytics du créateur (style PerfectPost)
      // Ne pas écraser les analytics existantes si les nouvelles sont vides
      try {
        // Vérifier que le contexte est encore valide avant d'appeler sendMessage
        if (!chrome.runtime || !chrome.runtime.id) {
          return; // Sortir silencieusement
        }
        
        let response = null;
        try {
          response = await new Promise((resolve, reject) => {
            chrome.runtime.sendMessage({ type: 'get_analytics' }, (response) => {
              if (chrome.runtime.lastError) {
                const errorMsg = chrome.runtime.lastError.message || '';
                if (errorMsg.includes('context invalidated') || errorMsg.includes('Receiving end does not exist')) {
                  resolve(null); // Ne pas bloquer, retourner null silencieusement
                } else {
                  reject(new Error(errorMsg));
                }
              } else {
                resolve(response);
              }
            });
          });
        } catch (err) {
          // Contexte invalidé ou autre erreur, sortir silencieusement
          return;
        }
        
        if (!response) return; // Contexte invalidé, arrêter
        
        const existingAnalytics = JSON.parse(localStorage.getItem('spost_analytics') || '{}');
        
        // Fusionner : garder les valeurs existantes si les nouvelles sont 0
        if (response) {
          const merged = { ...existingAnalytics };
          
          // Ne mettre à jour que si les nouvelles valeurs sont > 0
          if (response.totalFollowers > 0) merged.totalFollowers = response.totalFollowers;
          if (response.newFollowers > 0) merged.newFollowers = response.newFollowers;
          if (response.profileViews > 0) merged.profileViews = response.profileViews;
          if (response.totalImpressions > 0) merged.totalImpressions = response.totalImpressions;
          if (response.searchAppearances > 0) merged.searchAppearances = response.searchAppearances;
          if (response.postImpressions > 0) merged.postImpressions = response.postImpressions;
          
          merged.fetchedAt = response.fetchedAt || new Date().toISOString();
          
          localStorage.setItem('spost_analytics', JSON.stringify(merged));
          console.log('[S-Post Bridge] ✅ Analytics synchronisées:', merged);
          
          // Dispatcher un événement pour le BO
          window.dispatchEvent(new CustomEvent('SPostAnalyticsUpdated', { detail: merged }));
        }
      } catch (e) {
        // Pas d'analytics
      }
      
    } catch (error) {
      // Ne pas bloquer la page si le contexte est invalidé
      const errorMsg = error.message || error.toString() || '';
      
      // Détecter toutes les variantes de l'erreur "context invalidated"
      const isContextInvalidated = 
        errorMsg.includes('Extension context invalidated') ||
        errorMsg.includes('context invalidated') ||
        errorMsg.includes('Receiving end does not exist') ||
        errorMsg.includes('message port closed') ||
        (error.name === 'Error' && errorMsg.includes('context'));
      
      if (isContextInvalidated) {
        // Message silencieux, ne pas polluer la console
        // console.warn('[S-Post Bridge] Extension context invalidated (non bloquant)');
        return; // Sortir silencieusement
      } else {
        // Seulement les vraies erreurs sont loggées
        console.warn('[S-Post Bridge] Erreur sync (non bloquante):', errorMsg);
      }
      // Ne pas propager l'erreur pour éviter de bloquer la page
    }
  }
  
  // Synchroniser au chargement (après un court délai pour ne pas bloquer React)
  setTimeout(() => {
    syncToLocalStorage().catch(err => {
      // Ignorer silencieusement les erreurs de contexte invalidé
      const errorMsg = err?.message || err?.toString() || '';
      if (errorMsg.includes('context') || errorMsg.includes('invalidated')) {
        return; // Sortir silencieusement
      }
      // Seulement logger les vraies erreurs
      console.warn('[S-Post Bridge] Erreur sync (non bloquante):', errorMsg);
    });
  }, 1000);
  
  // Resynchroniser toutes les 30 secondes
  setInterval(() => {
    syncToLocalStorage().catch(err => {
      // Ignorer silencieusement les erreurs de contexte invalidé
      const errorMsg = err?.message || err?.toString() || '';
      if (errorMsg.includes('context') || errorMsg.includes('invalidated')) {
        return; // Sortir silencieusement
      }
      // Seulement logger les vraies erreurs
      console.warn('[S-Post Bridge] Erreur sync (non bloquante):', errorMsg);
    });
  }, 30000);

  // ============================================
  // Écouter les messages de l'app (unifié)
  // ============================================
  
  window.addEventListener('message', async (event) => {
    if (!event.data || !event.data.type) return;
    
    const { type, payload, requestId } = event.data;
    
    // Messages de l'app (ancien format - compatibilité)
    if (type.startsWith('LINKEDIN_PLANNER_')) {
      // Vérifier l'origine
      if (!event.origin.includes('localhost')) return;
      
      console.log('[S-Post] Message reçu de l\'app:', type);
      
      let response = null;
      
      switch (type) {
        case 'LINKEDIN_PLANNER_GET_DATA':
          response = await window.LinkedInPlanner.getData();
          break;
          
        case 'LINKEDIN_PLANNER_GET_LISTS':
          response = await window.LinkedInPlanner.getLists();
          break;
          
        case 'LINKEDIN_PLANNER_CREATE_LIST':
          response = await window.LinkedInPlanner.createList(payload.name);
          break;
          
        case 'LINKEDIN_PLANNER_GET_DRAFTS':
          response = await window.LinkedInPlanner.getDrafts();
          break;
          
        case 'LINKEDIN_PLANNER_SAVE_DRAFT':
          response = await window.LinkedInPlanner.saveDraft(payload);
          break;
          
        case 'LINKEDIN_PLANNER_DELETE_DRAFT':
          response = await window.LinkedInPlanner.deleteDraft(payload.id);
          break;
          
        case 'LINKEDIN_PLANNER_GET_POSTS':
        case 'SPOST_GET_POSTS':
          response = await window.LinkedInPlanner.getPosts();
          break;
          
        case 'LINKEDIN_PLANNER_FETCH_POSTS':
        case 'SPOST_FETCH_POSTS':
          response = await window.LinkedInPlanner.fetchPosts();
          break;
      }
      
      // Répondre à l'app
      window.postMessage({
        type: type + '_RESPONSE',
        payload: response,
      }, '*');
      return;
    }
    
    // Messages de la page (nouveau format - pour Notion + LinkedIn)
    if (event.source !== window) return;
    
    // ============================================
    // Vérification de disponibilité de l'extension
    // ============================================
    if (type === 'SPOST_EXTENSION_CHECK') {
      let version = 'unknown';
      let available = false;
      try {
        if (chrome.runtime && chrome.runtime.id && chrome.runtime.getManifest) {
          version = chrome.runtime.getManifest().version || 'unknown';
          available = true;
        }
      } catch (e) {
        console.warn('[S-Post Bridge] Erreur lors de la vérification:', e);
      }
      
      window.postMessage({
        type: 'SPOST_EXTENSION_CHECK_RESPONSE',
        requestId: event.data.requestId,
        available: available,
        version: version
      }, '*');
      return;
    }
    
    // ============================================
    // Appels Notion (MODULE SÉPARÉ)
    // ============================================
    if (type === 'SPOST_NOTION_API_CALL') {
      const { endpoint, method, body, token, headers, requestId } = event.data;
      
      console.log('[S-Post Bridge] Appel Notion API reçu:', { endpoint, method, hasToken: !!token, requestId });
      
      try {
        // Vérifier que le contexte est valide
        if (!chrome.runtime || !chrome.runtime.id) {
          window.postMessage({
            type: 'SPOST_NOTION_API_RESPONSE',
            requestId: requestId,
            error: 'Extension context invalidated. Please reload the page.'
          }, '*');
          return;
        }
        
        const response = await new Promise((resolve, reject) => {
          chrome.runtime.sendMessage({
            type: 'notion_api_call',
            endpoint: endpoint,
            method: method,
            body: body,
            token: token,
            headers: headers
          }, (response) => {
            if (chrome.runtime.lastError) {
              console.error('[S-Post Bridge] Erreur Notion API:', chrome.runtime.lastError);
              reject(new Error(chrome.runtime.lastError.message));
            } else if (response && response.error) {
              console.error('[S-Post Bridge] Erreur dans réponse Notion:', response.error);
              reject(new Error(response.error));
            } else {
              console.log('[S-Post Bridge] ✅ Réponse Notion API reçue');
              resolve(response);
            }
          });
        });
        
        window.postMessage({
          type: 'SPOST_NOTION_API_RESPONSE',
          requestId: requestId,
          response: response
        }, '*');
      } catch (error) {
        console.error('[S-Post Bridge] ❌ Erreur Notion API:', error);
        window.postMessage({
          type: 'SPOST_NOTION_API_RESPONSE',
          requestId: requestId,
          error: error.message
        }, '*');
      }
      return;
    }
    
    // ============================================
    // Appels LinkedIn (MODULE SÉPARÉ)
    // ============================================
    if (type === 'SPOST_LINKEDIN_API_CALL') {
      const { methodName, args, requestId } = event.data;
      
      if (!requestId) {
        console.warn('[S-Post Bridge] Appel LinkedIn sans requestId');
        return;
      }
      
      try {
        // Mapper les méthodes vers les types de messages du background script
        const methodMap = {
          'getData': 'get_linkedin_data',
          'getPosts': 'get_posts',
          'getDrafts': 'get_drafts',
          'getLists': 'get_list_refresh',
          'createList': 'create_list',
          'saveDraft': 'save_draft',
          'deleteDraft': 'delete_draft',
          'fetchPosts': 'fetch_linkedin_posts',
          'getScheduledPosts': 'get_scheduled_posts',
          'schedulePost': 'schedule_post',
          'updateScheduledPost': 'update_scheduled_post',
          'cancelScheduledPost': 'cancel_scheduled_post',
          'publishNow': 'publish_now'
        };
        
        const messageType = methodMap[methodName] || methodName;
        const messagePayload = args && args.length > 0 ? args[0] : {};
        
        // Vérifier que le contexte est valide
        if (!chrome.runtime || !chrome.runtime.id) {
          window.postMessage({
            type: 'SPOST_LINKEDIN_API_RESPONSE',
            requestId: requestId,
            error: 'Extension context invalidated. Please reload the page.'
          }, '*');
          return;
        }
        
        // Appel direct au runtime (pas via window.LinkedInPlanner pour éviter la récursion)
        const response = await new Promise((resolve, reject) => {
          const message = { type: messageType, ...messagePayload };
          
          chrome.runtime.sendMessage(message, (response) => {
            if (chrome.runtime.lastError) {
              const errorMsg = chrome.runtime.lastError.message || 'Extension error';
              if (errorMsg.includes('context invalidated') || errorMsg.includes('Receiving end does not exist')) {
                reject(new Error('Extension context invalidated. Please reload the page.'));
              } else {
                reject(new Error(errorMsg));
              }
            } else {
              resolve(response);
            }
          });
        });
        
        window.postMessage({
          type: 'SPOST_LINKEDIN_API_RESPONSE',
          requestId: requestId,
          response: response
        }, '*');
      } catch (error) {
        window.postMessage({
          type: 'SPOST_LINKEDIN_API_RESPONSE',
          requestId: requestId,
          error: error.message || error.toString()
        }, '*');
      }
    }
  });
  
  // ============================================
  // NOUVELLE APPROCHE : Pas d'injection de script
  // Utilisation uniquement de window.postMessage (comme PerfectPost)
  // Cela évite complètement les erreurs CSP
  // ============================================
  
  // Créer un wrapper simple dans le contexte du content script
  // qui sera accessible via window.postMessage
  console.log('[S-Post Bridge] ✅ Bridge prêt - Communication via window.postMessage uniquement');
  
  // Émettre un événement pour indiquer que le bridge est prêt
  try {
    let version = 'unknown';
    try {
      if (chrome.runtime && chrome.runtime.getManifest) {
        version = chrome.runtime.getManifest().version || 'unknown';
      }
    } catch (e) {
      console.warn('[S-Post Bridge] Impossible de récupérer la version:', e);
    }
    
    window.dispatchEvent(new CustomEvent('SPostBridgeReady', {
      detail: { version: version }
    }));
    
    console.log('[S-Post Bridge] ✅ Bridge prêt - window.SPost et window.LinkedInPlanner disponibles');
    console.log('[S-Post Bridge] Version:', version);
  } catch (e) {
    console.warn('[S-Post Bridge] Erreur lors de l\'émission de l\'événement:', e);
  }
  
  } catch (error) {
    // Ne pas bloquer la page en cas d'erreur - sortir silencieusement
    // La page doit continuer à fonctionner même si le bridge échoue
    // Ne pas logger pour éviter de polluer la console
  }
})();

